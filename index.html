<!DOCTYPE html>
<html>
<head>
<title>PDF Maker</title>
<meta charset="utf-8" />
<script src="https://unpkg.com/pdf-lib"></script>
<script src="https://unpkg.com/alpinejs" defer></script>
</head>

<body>
	<div x-data="{
		pages: [],
		nextPageKey: 1,
		async addPages(files) {
			for (const file of files) {
				this.pages.push({
					id: this.nextPageKey,
					url: await blobToDataURL(file),
					rotation: 0,
				});
				this.nextPageKey += 1;
			}
		},
	
		outputName: '',
		outputInches: '8.5',

		outputDataUri: null,
		async createPdf() {
			const pdfDoc = await PDFLib.PDFDocument.create();
			// PDF unit defined as 1/72th of an inch. Does not reject negative yet.
			// Feature idea: list both max width and max height, use tighter constraint
			const pageWidth = isNaN(this.outputInches) ? this.outputInches * 72 : 612;

			for (const pageData of this.pages) {
				const jpgImage = await pdfDoc.embedJpg(pageData.url);
				const {pageHeight, ...drawOptions} = getPageOptions(pageWidth, jpgImage, pageData.rotation);
				const page = pdfDoc.addPage([pageWidth, pageHeight])
				page.drawImage(jpgImage, drawOptions);
			}
			this.outputDataUri = await pdfDoc.saveAsBase64({ dataUri: true });
		},
	}">
		<label>
			Add pages:
			<input x-on:change="addPages($el.files)" type="file" id="file-input" x-ref="fileInput" multiple accept="image/jpeg"/>
		</label>
		<br>
		<label>
			Page width (inches):
			<input x-model="outputInches" placeholder="8.5">
		</label>
		<ul x-data="{
			toMove: null,

			// These functions work on the pages array
			getPageIndex(targetElement) {
				for (let i = 0; i < pages.length; ++i) {
					if (pages[i].id == targetElement.dataset.pageId) {
						return i;
					}
				}
				return pages.length; // Pretty safe failure value for our purposes
			},
			// Moves toMove within pages to offset + position of targetElement
			// offset is 0 or 1 for before or after
			moveTo(targetElement, offset) {
				const toMoveIndex = this.getPageIndex(this.toMove);
				const toMoveData = pages[toMoveIndex];
				// Some strange behavior if toMove is same as targetElement
				if (toMoveIndex === pages.length || this.toMove === null) {
					return;
				}
				pages.splice(toMoveIndex, 1);
				// Add toMove back to the proper position, either before or after
				pages.splice(offset + this.getPageIndex(targetElement), 0, toMoveData);
				this.toMove = null;
			},
		}">
			<template x-for="page in pages" :key="page.id">
				<li x-bind:data-page-id="page.id">
					<button x-on:click="toMove = $el.parentNode">move</button>
					<button x-on:click="moveTo($el.parentNode, 0)">before</button>
					<button x-on:click="moveTo($el.parentNode, 1)">after</button>
					<span style="display:inline-flex;justify-content:center;height:100px;width:100px">
					<img x-bind:src="page.url" x-bind:style="`transform:rotate(-${page.rotation}deg);max-height:100%;object-fit:contain;max-width:100%`" />
					</span>
					<button x-on:click="page.rotation = (page.rotation + 90) % 360">â†º rotate</button>
				</li>
			</template>
		</ul>
		<label>
			Save as:
			<input x-model="outputName" placeholder="filename">
		</label>
		<span>.pdf</span>
		<br>
		<button x-on:click="createPdf()">Generate PDF</button>
		<br>
		<a x-bind:href="outputDataUri" x-bind:download="outputName + '.pdf'">Download</a>
	</div>
</body>
<script>
// I'm not sure if this it is best practice to put this utility function here
// It appears not to be based on https://alpinejs.dev/essentials/state#re-usable-data
// and the page for Alpine.data(...), but it would be strange to move this to the main div
async function blobToDataURL(blob) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = () => resolve(reader.result);
		reader.onerror = () => reject(reader.error);
		reader.readAsDataURL(blob);
	});
}

function getPageOptions(pageWidth, jpgImage, rotate) {
	console.log(pageWidth, jpgImage, rotate);
	if (rotate != 0 && rotate != 90 && rotate != 180 && rotate != 270) {
		rotate = 0;
	}
	let result = {x: 0, y: 0, rotate: PDFLib.degrees(rotate)};
	if (rotate == 0 || rotate == 180) {
		result.pageHeight = pageWidth / jpgImage.width * jpgImage.height;
		result.width = pageWidth;
		result.height = result.pageHeight;
	} else {
		result.pageHeight = pageWidth / jpgImage.height * jpgImage.width;
		result.width = result.pageHeight;
		result.height = pageWidth;
	}
	if (rotate == 90 || rotate == 180) {
		result.x = pageWidth;
	}
	if (rotate == 180 || rotate == 270) {
		result.y = result.pageHeight;
	}
	console.log(result);
	return result;
}
</script>
</html>
