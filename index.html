<!DOCTYPE html>
<html>
<head>
<title>PDF Maker</title>
<meta charset="utf-8" />
<script src="https://unpkg.com/pdf-lib"></script>
<script src="https://unpkg.com/alpinejs" defer></script>
<style>
button {
	min-width: 30px;
}

/*
The styling is meant to somewhat resemble a PDF
Functionality is still the main concern, though
*/
.content {
	font-family: Open Sans,Arial;
	background-color: white;
    color: #454545;
    font-size: 16px;
    margin: 2em auto;
    max-width: 800px;
    padding: 1em;
    line-height: 1.4;
}

.input-line {
	border: none;
	border-bottom: 2px solid #454545;
}

body {
	background-color: #282828;
}

.page-row {
	display: flex;
}

.fake-button {
	color: blue;
}

hr {
	border-width: 1px;
	border-style: solid;
	margin: auto;
	margin-top: 1em;
	margin-bottom: 1em;
	width: 60%;
}
</style>
</head>

<body>
	<div class="content" x-data="{
		pages: [],
		nextPageKey: 1,
		async addPages(files) {
			for (const file of files) {
				this.pages.push({
					id: this.nextPageKey,
					url: await blobToDataURL(file),
					rotation: 0,
				});
				this.nextPageKey += 1;
			}
		},
	
		outputName: '',
		outputInches: '8.5',

		outputDataUri: null,
		async generateAndDownloadPdf() {
			// Alpine seems to mess with order of execution in some way
			// so this code might not be totally correct
			$refs.downloadButton.innerHTML = 'Generating PDF... (be patient)';
			try {
				await this.downloadPdf();
			} finally {
				$refs.downloadButton.innerHTML = 'Download';
			}
		},
		async downloadPdf() {
			const pdfDoc = await PDFLib.PDFDocument.create();
			// PDF unit defined as 1/72th of an inch. Does not reject negative yet.
			// Feature idea: list both max width and max height, use tighter constraint
			const pageWidth = isNaN(this.outputInches) ? this.outputInches * 72 : 612;

			for (const pageData of this.pages) {
				const jpgImage = await pdfDoc.embedJpg(pageData.url);
				const {pageHeight, ...drawOptions} = getPageOptions(pageWidth, jpgImage, pageData.rotation);
				const page = pdfDoc.addPage([pageWidth, pageHeight])
				page.drawImage(jpgImage, drawOptions);
			}

			this.outputDataUri = await pdfDoc.saveAsBase64({ dataUri: true });
			$refs.downloadLink.click();
		},
	}">
		<div>
			<label class="fake-button">
				Add pages
				<input style="opacity: 0" x-on:change="await addPages($el.files); $el.value = ''" type="file" id="file-input" x-ref="fileInput" multiple accept="image/jpeg"/>
			</label>
		</div>
		<div>
			<label>
				Page width:
				<input class="input-line" x-model="outputInches" placeholder="8.5">
			</label>
			inches
		</div>
		<hr />
		<div x-show="pages.length == 0">Click the blue "Add pages" to upload JPEGs for use here</div>
		<div x-data="{
			toMoveIndex: null,

			moveTo(targetElement, insertOffset) {
				if (this.toMoveIndex === null || isNaN(this.toMoveIndex)) {
					return;
				}

				const target = +targetElement.dataset.index;
				const toMove = pages[this.toMoveIndex];

				// We work on a copy to avoid weirdness with alpine trying
				// to update the page based on intermediate states
				const pagesCopy = [...pages];
				pagesCopy.splice(target + insertOffset, 0, toMove);
				
				if (target < this.toMoveIndex) {
					pagesCopy.splice(this.toMoveIndex + 1, 1);
				} else {
					pagesCopy.splice(this.toMoveIndex, 1);
				}

				pages = pagesCopy;
				this.toMoveIndex = null;
			},

			removePage() {
				if (this.toMoveIndex === null) {
					return;
				}
				pages.splice(this.toMoveIndex, 1);
				this.toMoveIndex = null;
			},
		}">
			<template x-for="(page, index) in pages" :key="page.id">
				<div class="page-row" x-bind:data-index="index">
					<button title="Select this page to be moved or deleted" x-show="toMoveIndex === null" x-on:click="toMoveIndex = +$el.parentNode.dataset.index">✥</button>
					<button title="Cancel the reordering" x-show="toMoveIndex !== null && toMoveIndex == index" x-on:click="toMoveIndex = null">→</button>
					<button title="Move the selected page to before this page" x-show="toMoveIndex !== null && toMoveIndex > index" x-on:click="moveTo($el.parentNode, 0)">↗</button>
					<button title="Move the selected page to after this page" x-show="toMoveIndex !== null && toMoveIndex < index" x-on:click="moveTo($el.parentNode, 1)">↘</button>
					<span style="display:inline-flex;justify-content:center;height:100px;width:100px">
					<img x-bind:src="page.url" x-bind:style="`transform:rotate(-${page.rotation}deg);max-height:100%;object-fit:contain;max-width:100%`" />
					</span>
					<button x-on:click="page.rotation = (page.rotation + 90) % 360">↺ rotate</button>
					<button title="Remove this page" x-show="toMoveIndex == index" x-on:click="removePage()" style="background-color:pink">×</button>
				</div>
			</template>
		</div>
		<hr />
		<div>
			<label>
				Save as:
				<input class="input-line" x-model="outputName" placeholder="filename">
			</label>
			<span>.pdf</span>
		</div>
		<div x-ref="downloadButton" class="fake-button" x-on:click="generateAndDownloadPdf()">Download</div>
		<a x-ref="downloadLink" x-bind:href="outputDataUri" x-bind:download="outputName + '.pdf'" style="display:none">Hidden download link for technical reasons</a>
	</div>
</body>
<script>
// I'm not sure if this it is best practice to put this utility function here
// It appears not to be based on https://alpinejs.dev/essentials/state#re-usable-data
// and the page for Alpine.data(...), but it would be strange to move this to the main div
async function blobToDataURL(blob) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onload = () => resolve(reader.result);
		reader.onerror = () => reject(reader.error);
		reader.readAsDataURL(blob);
	});
}

function getPageOptions(pageWidth, jpgImage, rotate) {
	// console.log(pageWidth, jpgImage, rotate);
	if (rotate != 0 && rotate != 90 && rotate != 180 && rotate != 270) {
		rotate = 0;
	}
	let result = {x: 0, y: 0, rotate: PDFLib.degrees(rotate)};
	if (rotate == 0 || rotate == 180) {
		result.pageHeight = pageWidth / jpgImage.width * jpgImage.height;
		result.width = pageWidth;
		result.height = result.pageHeight;
	} else {
		result.pageHeight = pageWidth / jpgImage.height * jpgImage.width;
		result.width = result.pageHeight;
		result.height = pageWidth;
	}
	if (rotate == 90 || rotate == 180) {
		result.x = pageWidth;
	}
	if (rotate == 180 || rotate == 270) {
		result.y = result.pageHeight;
	}
	// console.log(result);
	return result;
}
</script>
</html>
